<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nanoGPT Dashboard</title>
    <!-- Chart.js CDN for enhanced visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.min.js"></script>
    <!-- Three.js CDN for 3D parameter visualization -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            height: 100vh;
            display: grid;
            grid-template-rows: auto 1fr auto;
            background-color: white;
        }
        
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 10px 20px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 1.8em;
        }
        
        .content {
            display: grid;
            grid-template-columns: 250px 1fr;
            grid-template-rows: 1fr;
            gap: 15px;
            padding: 10px;
            overflow: hidden;
        }
        
        /* Metrics sidebar */
        .metrics-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .status-display {
            background-color: #ecf0f1;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            font-size: 0.9em;
        }
        
        .status-indicator {
            font-weight: bold;
            font-size: 1em;
        }
        
        .status-training { color: #27ae60; }
        .status-complete { color: #3498db; }
        .status-error { color: #e74c3c; }
        
        .metrics-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .metric-item {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
        }
        
        .metric-label {
            font-size: 0.8em;
            color: #7f8c8d;
            margin-bottom: 3px;
        }
        
        .metric-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #2c3e50;
        }
        
        /* Tab navigation */
        .tab-navigation {
            display: flex;
            background-color: #ecf0f1;
            border-radius: 8px 8px 0 0;
            border: 1px solid #dee2e6;
            border-bottom: none;
            overflow: hidden;
        }
        
        .tab-button {
            background-color: transparent;
            border: none;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            color: #7f8c8d;
            transition: all 0.2s ease;
            border-right: 1px solid #dee2e6;
        }
        
        .tab-button:last-child {
            border-right: none;
        }
        
        .tab-button:hover {
            background-color: #d5dbdb;
            color: #2c3e50;
        }
        
        .tab-button.active {
            background-color: #3498db;
            color: white;
        }
        
        /* Chart as main content */
        .chart-section {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .tab-content {
            display: none;
            flex: 1;
            height: 100%;
        }
        
        .tab-content.active {
            display: flex;
            flex-direction: column;
        }
        
        .chart-container {
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            padding: 15px;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .chart-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .chart-wrapper {
            position: relative;
            flex: 1;
            width: 100%;
            background-color: white;
            border-radius: 6px;
            border: 1px solid #ddd;
            padding: 15px;
            box-sizing: border-box;
            min-height: 450px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chart-canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 400px;
        }
        
        #loss-chart-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Fallback canvas styles for backwards compatibility */
        #loss-chart {
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            max-width: 100%;
            height: auto;
        }
        
        /* 3D Parameter visualization styles */
        .parameter-visualization {
            background-color: #f8f9fa;
            border-radius: 0 0 8px 8px;
            border: 1px solid #dee2e6;
            border-top: none;
            padding: 15px;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .parameter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: white;
            border-radius: 6px;
            border: 1px solid #ddd;
            flex-wrap: wrap;
        }
        
        .settings-panel {
            background-color: white;
            border-radius: 6px;
            border: 1px solid #ddd;
            margin-bottom: 15px;
            overflow: hidden;
        }
        
        .settings-header {
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            color: #2c3e50;
        }
        
        .settings-header:hover {
            background-color: #e9ecef;
        }
        
        .settings-content {
            padding: 15px;
            display: none;
        }
        
        .settings-content.expanded {
            display: block;
        }
        
        .settings-row {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .settings-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 120px;
        }
        
        .settings-group label {
            font-size: 0.8em;
            color: #7f8c8d;
            font-weight: 500;
        }
        
        .toggle-icon {
            transition: transform 0.2s ease;
        }
        
        .toggle-icon.expanded {
            transform: rotate(180deg);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group label {
            font-size: 0.8em;
            color: #7f8c8d;
            font-weight: 500;
        }
        
        .parameter-3d-container {
            position: relative;
            flex: 1;
            background-color: #2c3e50;
            border-radius: 6px;
            border: 1px solid #ddd;
            min-height: 400px;
            overflow: hidden;
        }
        
        #parameter-3d-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .parameter-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8em;
            font-family: monospace;
            pointer-events: none;
            max-width: 300px;
            white-space: pre-line;
        }
        
        .parameter-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.8em;
            font-family: monospace;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
            white-space: pre-line;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .parameter-details {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 0.8em;
            font-family: monospace;
            pointer-events: none;
            max-width: 200px;
            white-space: pre-line;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .parameter-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ecf0f1;
            font-size: 1.1em;
            text-align: center;
        }
        
        /* Footer */
        .footer {
            background-color: #ecf0f1;
            padding: 8px 20px;
            text-align: center;
            font-size: 0.8em;
            color: #7f8c8d;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                gap: 10px;
            }
            
            .metrics-section {
                flex-direction: row;
                overflow-x: auto;
            }
            
            .metrics-grid {
                flex-direction: row;
                min-width: 600px;
            }
            
            .metric-item {
                min-width: 120px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>nanoGPT Dashboard</h1>
        </header>
        
        <main class="content">
            <!-- Metrics sidebar -->
            <section class="metrics-section" id="metrics">
                <!-- Status display -->
                <div class="status-display">
                    <div class="status-indicator" id="status">
                        Status: <span id="status-value" class="status-training">Initializing</span>
                    </div>
                </div>
                
                <!-- Metrics grid -->
                <div class="metrics-grid">
                    <div class="metric-item">
                        <div class="metric-label">Iteration</div>
                        <div class="metric-value" id="iteration-value">0</div>
                    </div>
                    
                    <div class="metric-item">
                        <div class="metric-label">Loss</div>
                        <div class="metric-value" id="loss-value">--</div>
                    </div>
                    
                    <div class="metric-item">
                        <div class="metric-label">Elapsed Time</div>
                        <div class="metric-value" id="elapsed-value">00:00:00</div>
                    </div>
                </div>
            </section>
            
            <!-- Tabbed visualization area -->
            <section class="chart-section" id="visualization">
                <!-- Tab navigation -->
                <div class="tab-navigation">
                    <button class="tab-button active" onclick="switchTab('loss-chart-tab')">Loss Chart</button>
                    <button class="tab-button" onclick="switchTab('parameter-viz-tab')">Parameter Visualization</button>
                </div>
                
                <!-- Loss Chart Tab -->
                <div id="loss-chart-tab" class="tab-content active">
                    <div class="chart-container">
                        <div class="chart-title">Training Loss Curve</div>
                        <div class="chart-wrapper">
                            <div class="chart-canvas-container">
                                <!-- Chart.js enhanced canvas -->
                                <canvas id="loss-chart-canvas"></canvas>
                                <!-- Fallback canvas for backwards compatibility -->
                                <canvas id="loss-chart" width="800" height="400" style="display: none;">
                                    Your browser does not support the HTML5 Canvas element. Please upgrade to a modern browser to view the training loss chart.
                                </canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Parameter Visualization Tab -->
                <div id="parameter-viz-tab" class="tab-content">
                    <div class="parameter-visualization">
                        <!-- Quick Controls -->
                        <div class="parameter-controls">
                            <div class="control-group">
                                <label>Parameter Type</label>
                                <select id="parameter-type-select">
                                    <option value="all">All Parameters</option>
                                    <option value="token_embeddings">Token Embeddings</option>
                                    <option value="position_embeddings">Position Embeddings</option>
                                    <option value="layer_weights">Layer Weights</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Layer Filter</label>
                                <select id="layer-filter-select">
                                    <option value="all">All Layers</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Show/Hide</label>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="show-tokens" checked>
                                        <span style="font-size: 0.8em;">Tokens</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="show-positions" checked>
                                        <span style="font-size: 0.8em;">Positions</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="show-layers" checked>
                                        <span style="font-size: 0.8em;">Layers</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Advanced Settings Panel -->
                        <div class="settings-panel">
                            <div class="settings-header" onclick="toggleSettingsPanel()">
                                <span>Visualization Settings</span>
                                <span class="toggle-icon" id="settings-toggle">â–¼</span>
                            </div>
                            <div class="settings-content" id="settings-content">
                                <div class="settings-row">
                                    <div class="settings-group">
                                        <label>Point Size</label>
                                        <input type="range" id="point-size-slider" min="1" max="10" value="3">
                                        <span id="point-size-value">3</span>
                                    </div>
                                    <div class="settings-group">
                                        <label>Color Scheme</label>
                                        <select id="color-scheme-select">
                                            <option value="magnitude">By Magnitude</option>
                                            <option value="type">By Type</option>
                                            <option value="layer">By Layer</option>
                                        </select>
                                    </div>
                                    <div class="settings-group">
                                        <label>Animation Speed</label>
                                        <input type="range" id="animation-speed-slider" min="0.1" max="2" step="0.1" value="1">
                                        <span id="animation-speed-value">1.0x</span>
                                    </div>
                                </div>
                                <div class="settings-row">
                                    <div class="settings-group">
                                        <label>Point Opacity</label>
                                        <input type="range" id="point-opacity-slider" min="0.1" max="1" step="0.1" value="0.8">
                                        <span id="point-opacity-value">0.8</span>
                                    </div>
                                    <div class="settings-group">
                                        <label>Background</label>
                                        <select id="background-select">
                                            <option value="dark">Dark</option>
                                            <option value="light">Light</option>
                                            <option value="gradient">Gradient</option>
                                        </select>
                                    </div>
                                    <div class="settings-group">
                                        <label>Grid</label>
                                        <label style="display: flex; align-items: center; gap: 5px;">
                                            <input type="checkbox" id="show-grid" checked>
                                            <span style="font-size: 0.8em;">Show Grid</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="parameter-3d-container">
                            <canvas id="parameter-3d-canvas"></canvas>
                            <div class="parameter-info" id="parameter-info">
                                Waiting for parameter data...
                            </div>
                            <div class="parameter-details" id="parameter-details" style="display: none;">
                                Parameter details will appear here
                            </div>
                            <div class="parameter-loading" id="parameter-loading">
                                Loading 3D visualization...
                            </div>
                        </div>
                        <div class="parameter-tooltip" id="parameter-tooltip" style="display: none;"></div>
                    </div>
                </div>
            </section>
        </main>
        
        <footer class="footer">
            nanoGPT Dashboard - Real-time Training Visualization
        </footer>
    </div>
    
    <script>
        // WebSocket connection management
        let connectionStatus = 'disconnected';
        let websocket = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectTimeout = null;
        let lastDataTimestamp = 0;
        let pingInterval = null;
        let connectionUrl = null;
        
        // Fallback HTTP polling for when WebSocket is not available
        let pollingInterval = null;
        let pollingIntervalMs = 2000;
        let useWebSocketFallback = false;
        
        // Chart rendering variables
        let canvas = null;
        let ctx = null;
        let lossData = [];
        let chartPadding = { top: 40, right: 40, bottom: 60, left: 80 };
        let gridColor = '#e0e0e0';
        let lineColor = '#3498db';
        let axisColor = '#666';
        
        // Chart.js configuration and variables
        let lossChart = null;
        let useChartJs = false;
        
        // Memory management configuration and monitoring
        let memoryMonitoringEnabled = true;
        let memoryCheckInterval = 30000; // Check memory every 30 seconds
        let memoryLimitMB = 512; // Browser memory limit in MB (Requirement 1)
        let memoryMonitorInterval = null;
        let lastMemoryCheck = 0;
        let memoryCheckHistory = [];
        
        // Chart.js configuration object - centralized for easy customization
        const chartConfig = {
            // Performance settings optimized for WebSocket real-time updates
            maxDataPoints: 1000,
            maxUpdateRate: 10, // Updates per second (Requirement 1.2: <500ms updates)
            animationDuration: 200, // Fast animation for real-time feel
            batchUpdateThreshold: 5, // Batch updates if more than 5 points queued
            
            // Visual settings
            colors: {
                primary: '#3498db',
                primaryAlpha: 'rgba(52, 152, 219, 0.1)',
                text: '#2c3e50',
                grid: '#e0e0e0',
                axis: '#666'
            },
            
            // Chart settings
            showPoints: true,
            smoothLines: true,
            responsive: true,
            maintainAspectRatio: false,
            resizeDelay: 200
        };
        
        let chartJsData = {
            labels: [],
            datasets: [{
                label: 'Training Loss',
                data: [], // Will contain {x, y, timestamp} objects for enhanced data points
                borderColor: chartConfig.colors.primary,
                backgroundColor: chartConfig.colors.primaryAlpha,
                borderWidth: 2,
                fill: false,
                tension: chartConfig.smoothLines ? 0.1 : 0,
                pointRadius: chartConfig.showPoints ? 2 : 0,
                pointHoverRadius: 6,
                pointBorderColor: chartConfig.colors.primary,
                pointBackgroundColor: chartConfig.colors.primary,
                // Enable parsing of object data points for Chart.js 4.x
                parsing: {
                    xAxisKey: 'x',
                    yAxisKey: 'y'
                }
            }],
            // Additional data arrays for enhanced tooltips
            timestamps: [],
            iterations: []
        };
        
        // Real-time update optimization for WebSocket messages
        let updateQueue = [];
        let isProcessingQueue = false;
        let lastChartUpdate = 0;
        
        // Initialize WebSocket connection with fallback to HTTP polling
        function initConnection() {
            connectionStatus = 'connecting';
            updateConnectionStatus();
            
            // Determine connection URL based on current protocol
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            connectionUrl = `${protocol}//${window.location.host}/ws`;
            
            // Try WebSocket first, fallback to HTTP polling if needed
            if (typeof WebSocket !== 'undefined') {
                initWebSocket();
            } else {
                console.warn('WebSocket not supported, falling back to HTTP polling');
                useWebSocketFallback = true;
                startPolling();
            }
        }
        
        // Initialize WebSocket connection for real-time chart updates
        function initWebSocket() {
            try {
                console.log('Attempting WebSocket connection to:', connectionUrl);
                websocket = new WebSocket(connectionUrl);
                
                // WebSocket event handlers
                websocket.onopen = function(event) {
                    console.log('WebSocket connected successfully');
                    connectionStatus = 'connected';
                    reconnectAttempts = 0;
                    clearReconnectTimeout();
                    updateConnectionStatus();
                    
                    // Start ping/pong to keep connection alive
                    startPingInterval();
                    
                    // Send initial connection message
                    sendWebSocketMessage({
                        type: 'client_connect',
                        timestamp: Date.now() / 1000
                    });
                };
                
                websocket.onmessage = function(event) {
                    try {
                        const message = JSON.parse(event.data);
                        handleIncomingMessage(message);
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };
                
                websocket.onclose = function(event) {
                    console.log('WebSocket connection closed:', event.code, event.reason);
                    connectionStatus = 'disconnected';
                    updateConnectionStatus();
                    stopPingInterval();
                    
                    // Attempt reconnection unless deliberately closed
                    if (event.code !== 1000 && reconnectAttempts < maxReconnectAttempts) {
                        scheduleReconnect();
                    } else if (event.code !== 1000) {
                        // Fall back to HTTP polling after max reconnect attempts
                        console.warn('WebSocket max reconnect attempts reached, falling back to HTTP polling');
                        useWebSocketFallback = true;
                        startPolling();
                    }
                };
                
                websocket.onerror = function(event) {
                    console.error('WebSocket error:', event);
                    
                    // If WebSocket fails immediately, fall back to HTTP polling
                    if (connectionStatus === 'connecting') {
                        console.warn('WebSocket connection failed, falling back to HTTP polling');
                        useWebSocketFallback = true;
                        startPolling();
                    }
                };
                
            } catch (error) {
                console.error('Error initializing WebSocket:', error);
                console.warn('Falling back to HTTP polling');
                useWebSocketFallback = true;
                startPolling();
            }
        }
        
        // Send message via WebSocket
        function sendWebSocketMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                try {
                    websocket.send(JSON.stringify(message));
                } catch (error) {
                    console.error('Error sending WebSocket message:', error);
                }
            }
        }
        
        // Start periodic ping to keep WebSocket connection alive
        function startPingInterval() {
            stopPingInterval(); // Clear any existing interval
            pingInterval = setInterval(() => {
                sendWebSocketMessage({
                    type: 'ping',
                    timestamp: Date.now() / 1000
                });
            }, 30000); // Ping every 30 seconds
        }
        
        // Stop ping interval
        function stopPingInterval() {
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
            }
        }
        
        function startPolling() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }
            
            pollingInterval = setInterval(pollForData, pollingIntervalMs);
            pollForData(); // Poll immediately
        }
        
        function pollForData() {
            fetch('/api/metrics')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (connectionStatus !== 'connected') {
                        connectionStatus = 'connected';
                        updateConnectionStatus();
                        console.log('Connected to dashboard API');
                    }
                    
                    if (data.status === 'success' && data.data && data.data.length > 0) {
                        handleIncomingData(data.data);
                    }
                })
                .catch(error => {
                    console.error('Polling error:', error);
                    if (connectionStatus !== 'error') {
                        connectionStatus = 'error';
                        updateConnectionStatus();
                    }
                });
        }
        
        // Handle incoming training data
        function handleIncomingData(dataArray) {
            for (const dataPoint of dataArray) {
                if (dataPoint.timestamp > lastDataTimestamp) {
                    lastDataTimestamp = dataPoint.timestamp;
                    updateTrainingMetrics(dataPoint);
                }
            }
        }
        
        // Schedule reconnection with exponential backoff
        function scheduleReconnect() {
            if (reconnectAttempts >= maxReconnectAttempts) {
                connectionStatus = 'failed';
                updateConnectionStatus();
                
                // Try HTTP polling as final fallback
                if (!useWebSocketFallback) {
                    console.warn('WebSocket reconnection failed, trying HTTP polling fallback');
                    useWebSocketFallback = true;
                    startPolling();
                }
                return;
            }
            
            const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
            reconnectAttempts++;
            connectionStatus = `reconnecting_${reconnectAttempts}`;
            updateConnectionStatus();
            
            reconnectTimeout = setTimeout(() => {
                console.log(`Reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts}`);
                if (useWebSocketFallback) {
                    // Retry HTTP polling
                    startPolling();
                } else {
                    // Retry WebSocket connection
                    initWebSocket();
                }
            }, delay);
        }
        
        // Update connection status display
        function updateConnectionStatus() {
            const statusElement = document.getElementById('status-value');
            let statusText, statusClass;
            
            if (connectionStatus === 'connected') {
                const connectionType = useWebSocketFallback ? 'Polling' : 'WebSocket';
                statusText = `Connected (${connectionType})`;
                statusClass = 'status-training';
            } else if (connectionStatus === 'error') {
                statusText = 'Connection Error';
                statusClass = 'status-error';
            } else if (connectionStatus === 'failed') {
                statusText = 'Connection Failed - Refresh to retry';
                statusClass = 'status-error';
            } else if (connectionStatus.startsWith('reconnecting_')) {
                const attempt = connectionStatus.split('_')[1];
                const connectionType = useWebSocketFallback ? 'Polling' : 'WebSocket';
                statusText = `Reconnecting ${connectionType}... (${attempt}/${maxReconnectAttempts})`;
                statusClass = 'status-complete';
            } else {
                statusText = 'Disconnected';
                statusClass = 'status-error';
            }
            
            statusElement.textContent = statusText;
            statusElement.className = statusClass;
        }
        
        // Enhanced WebSocket message handler for real-time chart updates
        function handleIncomingMessage(message) {
            try {
                // Validate message structure
                if (!message || typeof message !== 'object') {
                    console.warn('Invalid message received:', message);
                    return;
                }
                
                // Handle message based on type with enhanced error handling
                switch (message.type) {
                    case 'training_update':
                        if (message.data && typeof message.data === 'object') {
                            // Update timestamp for connection tracking
                            if (message.data.timestamp) {
                                lastDataTimestamp = message.data.timestamp;
                            }
                            
                            // Use queuing system for optimal WebSocket performance
                            queueTrainingMetricsUpdate(message.data);
                        } else {
                            console.warn('Invalid training_update data:', message.data);
                        }
                        break;
                        
                    case 'status_update':
                        if (message.data && typeof message.data === 'object') {
                            updateTrainingStatus(message.data);
                        } else {
                            console.warn('Invalid status_update data:', message.data);
                        }
                        break;
                        
                    case 'connection_status':
                        console.log('Connection status update:', message);
                        if (message.status === 'connected') {
                            console.log(`Connected as ${message.client_id} (${message.total_clients} total clients)`);
                        }
                        break;
                        
                    case 'client_count_update':
                        const clientCount = message.data?.count || message.connected_clients || 0;
                        console.log(`Connected clients: ${clientCount}`);
                        break;
                        
                    case 'parameter_update':
                        if (message.data && typeof message.data === 'object') {
                            handleParameterUpdate(message.data);
                        } else {
                            console.warn('Invalid parameter_update data:', message.data);
                        }
                        break;
                        
                    case 'pong':
                        // Handle ping/pong response for connection health
                        console.debug('Pong received, connection healthy');
                        break;
                        
                    case 'error':
                        console.error('Server error message:', message.data || message.message);
                        break;
                        
                    case 'batch_update':
                        // Handle multiple training updates in a single message for optimal performance
                        if (Array.isArray(message.data)) {
                            console.debug(`Received batch update with ${message.data.length} data points`);
                            
                            // Filter and validate data points
                            const validDataPoints = message.data.filter(dataPoint => {
                                if (!dataPoint || typeof dataPoint !== 'object') {
                                    return false;
                                }
                                
                                // Update timestamp tracking
                                if (dataPoint.timestamp) {
                                    lastDataTimestamp = Math.max(lastDataTimestamp, dataPoint.timestamp);
                                }
                                
                                return isValidDataPoint(dataPoint.iteration, dataPoint.loss);
                            });
                            
                            // Use optimized batch processing for chart updates
                            if (validDataPoints.length > 0) {
                                // Update individual metrics display with latest point
                                const latestPoint = validDataPoints[validDataPoints.length - 1];
                                updateTrainingMetrics(latestPoint);
                                
                                // Add all points to chart in batch for performance
                                if (validDataPoints.length > chartConfig.batchUpdateThreshold) {
                                    // Large batch - use optimized batch processing
                                    addBatchLossDataPoints(validDataPoints);
                                } else {
                                    // Small batch - use individual queuing system
                                    validDataPoints.forEach(dataPoint => {
                                        queueTrainingMetricsUpdate(dataPoint);
                                    });
                                }
                                
                                console.debug(`Processed ${validDataPoints.length} valid data points from batch`);
                            } else {
                                console.warn('No valid data points found in batch update');
                            }
                        } else {
                            console.warn('Invalid batch_update format - expected array:', message.data);
                        }
                        break;
                        
                    default:
                        console.log('Unknown message type:', message.type, message);
                }
                
            } catch (error) {
                console.error('Error processing WebSocket message:', error, message);
            }
        }
        
        // Format elapsed time as human-readable HH:MM:SS or MM:SS
        function formatElapsedTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return '00:00';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return hours > 0 ? `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}` : `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Format loss value with appropriate precision
        function formatLoss(loss) {
            if (isNaN(loss)) return '--';
            return loss.toFixed(4);
        }

        // Format iteration number with thousands separators
        function formatIteration(iteration) {
            if (isNaN(iteration)) return '0';
            return iteration.toLocaleString();
        }

        // Queue training metrics update for optimal WebSocket performance
        function queueTrainingMetricsUpdate(data) {
            updateQueue.push(data);
            
            // Process queue immediately if below threshold or force if queue is getting large
            if (updateQueue.length >= chartConfig.batchUpdateThreshold || updateQueue.length >= 10) {
                processUpdateQueue();
            } else if (!isProcessingQueue) {
                // Schedule processing with slight delay to batch rapid updates
                setTimeout(processUpdateQueue, 50);
            }
        }
        
        // Process queued updates in batch for optimal performance
        function processUpdateQueue() {
            if (isProcessingQueue || updateQueue.length === 0) {
                return;
            }
            
            isProcessingQueue = true;
            
            try {
                // Process all queued updates
                const updates = updateQueue.splice(0); // Take all updates and clear queue
                
                for (const data of updates) {
                    updateTrainingMetrics(data);
                }
                
                // Throttle chart updates for performance (Requirement 1.2: <500ms updates)
                const now = Date.now();
                if (now - lastChartUpdate >= (1000 / chartConfig.maxUpdateRate)) {
                    updateChartDisplay();
                    lastChartUpdate = now;
                }
                
            } catch (error) {
                console.error('Error processing update queue:', error);
            } finally {
                isProcessingQueue = false;
                
                // Check if more updates arrived while processing
                if (updateQueue.length > 0) {
                    setTimeout(processUpdateQueue, 10);
                }
            }
        }
        
        // Update chart display (separated from data processing for performance)
        function updateChartDisplay() {
            if (useChartJs && lossChart) {
                lossChart.update('none'); // No animation for real-time updates
            } else if (!useChartJs) {
                requestAnimationFrame(() => {
                    drawChart();
                });
            }
        }
        
        // Update training metrics display
        function updateTrainingMetrics(data) {
            if (data.iteration !== undefined) {
                document.getElementById('iteration-value').textContent = formatIteration(data.iteration);
            }
            if (data.loss !== undefined) {
                document.getElementById('loss-value').textContent = formatLoss(data.loss);
                
                // Update chart with new loss data point, including timestamp
                if (data.iteration !== undefined) {
                    addLossDataPoint(data.iteration, data.loss, data.timestamp);
                }
            }
            if (data.elapsed_time !== undefined) {
                document.getElementById('elapsed-value').textContent = formatElapsedTime(data.elapsed_time);
            }
        }
        
        // Update training status
        function updateTrainingStatus(data) {
            const statusElement = document.getElementById('status-value');
            if (data.status) {
                // Map status to display text and CSS class
                let statusText = data.message || data.status;
                let statusClass;
                
                switch (data.status.toLowerCase()) {
                    case 'training':
                        statusClass = 'status-training';
                        break;
                    case 'complete':
                        statusClass = 'status-complete';
                        statusText = data.message || 'Training Complete';
                        break;
                    case 'error':
                    case 'interrupted':
                        statusClass = 'status-error';
                        break;
                    default:
                        statusClass = 'status-training';
                }
                
                statusElement.textContent = statusText;
                statusElement.className = statusClass;
                
                // Preserve final metrics when training completes
                if (data.final && (data.status === 'complete' || data.status === 'error' || data.status === 'interrupted')) {
                    // Final state reached - preserve current chart and metrics
                    console.log(`Training ${data.status}: Final metrics preserved`);
                }
            }
        }
        
        // Clear reconnection timeout
        function clearReconnectTimeout() {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
        }
        
        // Configure chart settings dynamically
        function configureChart(options = {}) {
            // Merge provided options with default config
            Object.assign(chartConfig, options);
            
            // Update chart data properties based on new config
            if (chartJsData.datasets[0]) {
                chartJsData.datasets[0].borderColor = chartConfig.colors.primary;
                chartJsData.datasets[0].backgroundColor = chartConfig.colors.primaryAlpha;
                chartJsData.datasets[0].tension = chartConfig.smoothLines ? 0.1 : 0;
                chartJsData.datasets[0].pointRadius = chartConfig.showPoints ? 2 : 0;
                chartJsData.datasets[0].pointBorderColor = chartConfig.colors.primary;
                chartJsData.datasets[0].pointBackgroundColor = chartConfig.colors.primary;
            }
            
            console.log('Chart configuration updated:', chartConfig);
        }
        
        // Memory monitoring and management functions (Requirement 1: Memory limit 512MB)
        
        // Start memory monitoring for long training sessions
        function startMemoryMonitoring() {
            if (!memoryMonitoringEnabled) {
                return;
            }
            
            console.log('Starting client-side memory monitoring');
            
            // Stop any existing monitoring
            stopMemoryMonitoring();
            
            // Start periodic memory checks
            memoryMonitorInterval = setInterval(checkMemoryUsage, memoryCheckInterval);
            
            // Perform initial memory check
            checkMemoryUsage();
        }
        
        // Stop memory monitoring
        function stopMemoryMonitoring() {
            if (memoryMonitorInterval) {
                clearInterval(memoryMonitorInterval);
                memoryMonitorInterval = null;
                console.log('Stopped client-side memory monitoring');
            }
        }
        
        // Check current memory usage and trigger cleanup if needed
        function checkMemoryUsage() {
            if (!memoryMonitoringEnabled) {
                return;
            }
            
            try {
                // Use Performance API to get memory information (when available)
                let memoryInfo = null;
                let memoryUsageMB = 0;
                
                // Check for Performance Memory API (Chrome/Chromium browsers)
                if (performance.memory) {
                    memoryInfo = performance.memory;
                    memoryUsageMB = memoryInfo.usedJSHeapSize / (1024 * 1024); // Convert to MB
                    
                    console.debug(`Memory usage: ${memoryUsageMB.toFixed(2)}MB (limit: ${memoryLimitMB}MB)`);
                    
                    // Store memory check in history for trend analysis
                    memoryCheckHistory.push({
                        timestamp: Date.now(),
                        memoryUsageMB: memoryUsageMB,
                        totalHeapSize: memoryInfo.totalJSHeapSize / (1024 * 1024),
                        heapSizeLimit: memoryInfo.jsHeapSizeLimit / (1024 * 1024),
                        dataPoints: getCurrentDataPointCount()
                    });
                    
                    // Keep only last 20 memory checks in history
                    if (memoryCheckHistory.length > 20) {
                        memoryCheckHistory.shift();
                    }
                    
                    // Check if memory usage exceeds limit (Requirement 1.8)
                    if (memoryUsageMB > memoryLimitMB) {
                        console.warn(`Memory usage (${memoryUsageMB.toFixed(2)}MB) exceeds limit (${memoryLimitMB}MB) - triggering cleanup`);
                        performMemoryCleanup('memory_limit_exceeded');
                        return;
                    }
                    
                } else {
                    // Fallback: Estimate memory usage based on data points
                    const dataPointCount = getCurrentDataPointCount();
                    const estimatedMemoryMB = estimateMemoryUsage(dataPointCount);
                    
                    console.debug(`Estimated memory usage: ${estimatedMemoryMB.toFixed(2)}MB (${dataPointCount} data points)`);
                    
                    if (estimatedMemoryMB > memoryLimitMB) {
                        console.warn(`Estimated memory usage exceeds limit - triggering cleanup`);
                        performMemoryCleanup('estimated_limit_exceeded');
                        return;
                    }
                }
                
                lastMemoryCheck = Date.now();
                
            } catch (error) {
                console.error('Error during memory check:', error);
                // Continue without memory monitoring to avoid disrupting dashboard
            }
        }
        
        // Get current total data point count across all data structures
        function getCurrentDataPointCount() {
            let totalPoints = 0;
            
            // Chart.js data points
            if (useChartJs && lossChart && lossChart.data) {
                totalPoints += lossChart.data.labels.length;
                totalPoints += lossChart.data.datasets[0].data.length;
                totalPoints += chartJsData.timestamps.length;
                totalPoints += chartJsData.iterations.length;
            }
            
            // Canvas fallback data points
            if (!useChartJs) {
                totalPoints += lossData.length;
            }
            
            return totalPoints;
        }
        
        // Estimate memory usage based on data point count (fallback for browsers without Performance API)
        function estimateMemoryUsage(dataPointCount) {
            // Rough estimation: each data point uses ~200 bytes on average
            // (including Chart.js overhead, timestamps, iteration numbers, etc.)
            const bytesPerDataPoint = 200;
            const baseMemoryMB = 50; // Base dashboard memory usage
            
            return baseMemoryMB + (dataPointCount * bytesPerDataPoint) / (1024 * 1024);
        }
        
        // Perform memory cleanup when limits are exceeded
        function performMemoryCleanup(reason) {
            console.log(`Performing memory cleanup (reason: ${reason})`);
            
            try {
                const beforeCount = getCurrentDataPointCount();
                
                // Calculate how many points to remove (remove 30% of data to provide buffer)
                const removalPercentage = 0.3;
                let pointsToRemove = Math.floor(beforeCount * removalPercentage);
                
                // Ensure we remove at least 100 points if we have them
                pointsToRemove = Math.max(pointsToRemove, Math.min(100, beforeCount - 200));
                
                if (pointsToRemove > 0) {
                    removeOldestDataPoints(pointsToRemove);
                    
                    const afterCount = getCurrentDataPointCount();
                    console.log(`Memory cleanup completed: removed ${beforeCount - afterCount} data points`);
                    
                    // Force chart update after cleanup
                    updateChartDisplay();
                    
                    // Schedule immediate garbage collection hint if available
                    if (window.gc && typeof window.gc === 'function') {
                        setTimeout(() => {
                            try {
                                window.gc();
                                console.debug('Triggered garbage collection after memory cleanup');
                            } catch (e) {
                                console.debug('Garbage collection hint failed:', e);
                            }
                        }, 100);
                    }
                }
                
            } catch (error) {
                console.error('Error during memory cleanup:', error);
            }
        }
        
        // Remove oldest data points from all data structures
        function removeOldestDataPoints(pointsToRemove) {
            if (pointsToRemove <= 0) {
                return;
            }
            
            console.debug(`Removing ${pointsToRemove} oldest data points for memory management`);
            
            if (useChartJs && lossChart && lossChart.data) {
                // Remove from Chart.js data structures
                const data = lossChart.data;
                const actualRemoval = Math.min(pointsToRemove, data.labels.length);
                
                if (actualRemoval > 0) {
                    // Use Chart.js optimized removal (splice is more efficient for large removals)
                    data.labels.splice(0, actualRemoval);
                    data.datasets[0].data.splice(0, actualRemoval);
                    chartJsData.timestamps.splice(0, actualRemoval);
                    chartJsData.iterations.splice(0, actualRemoval);
                }
                
            } else if (!useChartJs) {
                // Remove from canvas fallback data
                const actualRemoval = Math.min(pointsToRemove, lossData.length);
                if (actualRemoval > 0) {
                    lossData.splice(0, actualRemoval);
                }
            }
        }
        
        // Get memory monitoring statistics for debugging
        function getMemoryStats() {
            const stats = {
                monitoringEnabled: memoryMonitoringEnabled,
                lastCheck: lastMemoryCheck,
                checkInterval: memoryCheckInterval,
                memoryLimit: memoryLimitMB,
                dataPoints: getCurrentDataPointCount(),
                historyLength: memoryCheckHistory.length
            };
            
            if (performance.memory) {
                stats.currentMemory = {
                    usedMB: (performance.memory.usedJSHeapSize / (1024 * 1024)).toFixed(2),
                    totalMB: (performance.memory.totalJSHeapSize / (1024 * 1024)).toFixed(2),
                    limitMB: (performance.memory.jsHeapSizeLimit / (1024 * 1024)).toFixed(2)
                };
            }
            
            return stats;
        }
        
        // Expose memory monitoring functions globally for debugging and testing
        window.dashboardMemory = {
            getStats: getMemoryStats,
            checkNow: checkMemoryUsage,
            triggerCleanup: () => performMemoryCleanup('manual_trigger'),
            startMonitoring: startMemoryMonitoring,
            stopMonitoring: stopMemoryMonitoring,
            getCurrentDataPoints: getCurrentDataPointCount,
            setMemoryLimit: (limitMB) => {
                memoryLimitMB = limitMB;
                console.log(`Memory limit updated to ${limitMB}MB`);
            },
            getMemoryHistory: () => memoryCheckHistory.slice() // Return copy of history
        };
        
        // Initialize chart with Chart.js or fallback to canvas
        function initChart() {
            console.log('Initializing chart with configuration:', chartConfig);
            
            // Try to initialize Chart.js first
            if (typeof Chart !== 'undefined') {
                try {
                    initChartJs();
                    useChartJs = true;
                    console.log('Chart.js initialization successful');
                    console.log('Chart features: Real-time updates, Interactive tooltips, Responsive design');
                    return;
                } catch (error) {
                    console.error('Chart.js initialization failed:', error);
                    console.warn('Falling back to canvas implementation');
                }
            } else {
                console.warn('Chart.js library not available, using fallback canvas chart');
            }
            
            // Fallback to canvas implementation
            useChartJs = false;
            try {
                initCanvasChart();
                console.log('Fallback canvas chart initialized successfully');
            } catch (error) {
                console.error('Failed to initialize fallback canvas chart:', error);
                console.log('Chart display will be unavailable for this session');
            }
        }
        
        // Initialize Chart.js chart with enhanced configuration
        function initChartJs() {
            try {
                const canvasElement = document.getElementById('loss-chart-canvas');
                if (!canvasElement) {
                    console.error('Canvas element not found');
                    return false;
                }
                
                // Ensure the container has dimensions
                const container = canvasElement.parentElement;
                if (container.clientHeight === 0 || container.clientWidth === 0) {
                    console.log('Container has no dimensions, retrying...');
                    setTimeout(initChartJs, 100);
                    return false;
                }
                
                console.log('Initializing Chart.js with container dimensions:', container.clientWidth, 'x', container.clientHeight);
                
                const ctx = canvasElement.getContext('2d');
                
                lossChart = new Chart(ctx, {
                type: 'line',
                data: chartJsData,
                options: {
                    responsive: chartConfig.responsive,
                    maintainAspectRatio: chartConfig.maintainAspectRatio,
                    
                    // Layout configuration for proper spacing and visibility
                    layout: {
                        padding: {
                            top: 10,
                            bottom: 15,
                            left: 15,
                            right: 15
                        }
                    },
                    
                    // Enhanced animation configuration for real-time updates
                    animation: {
                        duration: chartConfig.animationDuration, // Reduced for faster real-time updates (Requirement 1.2)
                        easing: 'easeInOutQuart'
                    },
                    
                    // Performance optimizations for real-time data
                    datasets: {
                        line: {
                            pointRadius: function(context) {
                                // Show points only for the last few data points
                                const index = context.dataIndex;
                                const total = context.dataset.data.length;
                                return (total - index) <= 10 ? 3 : 1;
                            },
                            pointHoverRadius: 5
                        }
                    },
                    
                    // Enhanced scales with dynamic range and better formatting
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Iteration',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                },
                                color: '#2c3e50'
                            },
                            grid: {
                                color: '#e0e0e0',
                                drawOnChartArea: true
                            },
                            ticks: {
                                callback: function(value) {
                                    // Format large iteration numbers with K/M suffixes
                                    if (value >= 1000000) {
                                        return (value / 1000000).toFixed(1) + 'M';
                                    } else if (value >= 1000) {
                                        return (value / 1000).toFixed(0) + 'K';
                                    }
                                    return value.toString();
                                },
                                maxTicksLimit: 10,
                                color: chartConfig.colors.axis
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Loss',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                },
                                color: '#2c3e50'
                            },
                            grid: {
                                color: '#e0e0e0',
                                drawOnChartArea: true
                            },
                            ticks: {
                                callback: function(value) {
                                    // Format loss values with appropriate precision
                                    if (value < 0.01) {
                                        return value.toExponential(2);
                                    }
                                    return value.toFixed(4);
                                },
                                maxTicksLimit: 8,
                                color: '#666'
                            },
                            // Auto-scale with padding for better visualization
                            beginAtZero: false,
                            grace: '5%'
                        }
                    },
                    
                    // Enhanced plugins configuration
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                font: {
                                    size: 12
                                },
                                color: '#2c3e50'
                            }
                        },
                        
                        // Enhanced tooltip with detailed metric information (Requirement 1.3 - Task 1.6)
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(44, 62, 80, 0.95)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#3498db',
                            borderWidth: 2,
                            cornerRadius: 8,
                            displayColors: true,
                            titleFont: {
                                size: 14,
                                weight: 'bold'
                            },
                            bodyFont: {
                                size: 12
                            },
                            footerFont: {
                                size: 11,
                                style: 'italic'
                            },
                            padding: 12,
                            callbacks: {
                                title: function(context) {
                                    // Enhanced title with iteration formatting
                                    const iteration = context[0].label || context[0].parsed.x;
                                    const formattedIteration = parseInt(iteration).toLocaleString();
                                    return `Training Step ${formattedIteration}`;
                                },
                                label: function(context) {
                                    const loss = context.parsed.y;
                                    const precision = loss < 0.001 ? 8 : 6;
                                    return `Loss: ${loss.toFixed(precision)}`;
                                },
                                afterLabel: function(context) {
                                    const dataIndex = context.dataIndex;
                                    const dataPoint = context.dataset.data[dataIndex];
                                    const lines = [];
                                    
                                    // Get timestamp from data point or tracking arrays
                                    let timestamp = null;
                                    if (dataPoint && typeof dataPoint === 'object' && dataPoint.timestamp) {
                                        timestamp = dataPoint.timestamp;
                                    } else if (chartJsData.timestamps && chartJsData.timestamps[dataIndex]) {
                                        timestamp = chartJsData.timestamps[dataIndex];
                                    }
                                    
                                    // Add formatted timestamp
                                    if (timestamp) {
                                        const date = new Date(timestamp * 1000);
                                        const timeStr = date.toLocaleTimeString();
                                        const dateStr = date.toLocaleDateString();
                                        lines.push(`Time: ${timeStr}`);
                                        lines.push(`Date: ${dateStr}`);
                                    }
                                    
                                    // Add training progress metrics if available
                                    const iteration = context.parsed.x;
                                    const loss = context.parsed.y;
                                    
                                    // Calculate training rate if we have multiple points
                                    if (dataIndex > 0 && chartJsData.timestamps && chartJsData.timestamps[dataIndex - 1]) {
                                        const prevTimestamp = chartJsData.timestamps[dataIndex - 1];
                                        const prevIteration = chartJsData.iterations[dataIndex - 1];
                                        
                                        if (timestamp && prevTimestamp && iteration > prevIteration) {
                                            const timeDiff = timestamp - prevTimestamp;
                                            const iterDiff = iteration - prevIteration;
                                            const rate = iterDiff / timeDiff;
                                            lines.push(`Rate: ${rate.toFixed(2)} iter/sec`);
                                        }
                                    }
                                    
                                    // Calculate loss change if we have previous point
                                    if (dataIndex > 0 && context.dataset.data[dataIndex - 1]) {
                                        const prevLoss = context.dataset.data[dataIndex - 1].y || context.dataset.data[dataIndex - 1];
                                        const lossChange = loss - prevLoss;
                                        const lossChangePercent = ((lossChange / prevLoss) * 100);
                                        
                                        const changeSymbol = lossChange > 0 ? 'â†‘' : 'â†“';
                                        const changeColor = lossChange > 0 ? 'red' : 'green';
                                        lines.push(`Change: ${changeSymbol} ${Math.abs(lossChange).toFixed(6)} (${lossChangePercent.toFixed(2)}%)`);
                                    }
                                    
                                    // Add data point position info
                                    const totalPoints = context.dataset.data.length;
                                    lines.push(`Point: ${dataIndex + 1} of ${totalPoints}`);
                                    
                                    return lines;
                                },
                                footer: function(context) {
                                    const dataIndex = context[0].dataIndex;
                                    const totalPoints = context[0].dataset.data.length;
                                    
                                    // Add progress indicator for long training runs
                                    if (totalPoints > 10) {
                                        const progress = ((dataIndex + 1) / totalPoints * 100).toFixed(1);
                                        return `Progress: ${progress}% through displayed data`;
                                    }
                                    
                                    return 'Hover over points for detailed metrics';
                                }
                            }
                        }
                    },
                    
                    // Enhanced interaction configuration
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    
                    // Memory and performance management for real-time updates
                    elements: {
                        line: {
                            tension: 0.1, // Smooth curves
                            borderWidth: 2
                        },
                        point: {
                            radius: 2,
                            hoverRadius: 6,
                            hitRadius: 10
                        }
                    }
                }
            });
            
            // Add chart update method for better performance management
            lossChart.updateRealtime = function(maxUpdateRate = 10) {
                // Throttle updates to prevent performance issues
                const now = Date.now();
                if (!this.lastUpdate || (now - this.lastUpdate) >= (1000 / maxUpdateRate)) {
                    this.update('none'); // No animation for real-time updates
                    this.lastUpdate = now;
                }
            };
            
            console.log('âœ… Chart.js successfully initialized!');
            return true;
            
        } catch (error) {
            console.error('âŒ Failed to initialize Chart.js:', error);
            console.log('Falling back to canvas implementation...');
            initCanvasChart();
            return false;
        }
        }
        
        // Initialize fallback canvas chart
        function initCanvasChart() {
            canvas = document.getElementById('loss-chart');
            canvas.style.display = 'block';
            ctx = canvas.getContext('2d');
            drawChart();
        }
        
        // Draw the complete chart
        function drawChart() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid and axes
            drawGrid();
            drawAxes();
            
            // Draw loss curve if data exists
            if (lossData.length > 0) {
                drawLossLine();
            } else {
                drawEmptyMessage();
            }
        }
        
        // Draw grid lines
        function drawGrid() {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            
            const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
            const chartHeight = canvas.height - chartPadding.top - chartPadding.bottom;
            
            // Vertical grid lines
            for (let i = 0; i <= 10; i++) {
                const x = chartPadding.left + (chartWidth * i / 10);
                ctx.beginPath();
                ctx.moveTo(x, chartPadding.top);
                ctx.lineTo(x, chartPadding.top + chartHeight);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let i = 0; i <= 8; i++) {
                const y = chartPadding.top + (chartHeight * i / 8);
                ctx.beginPath();
                ctx.moveTo(chartPadding.left, y);
                ctx.lineTo(chartPadding.left + chartWidth, y);
                ctx.stroke();
            }
        }
        
        // Draw chart axes with labels
        function drawAxes() {
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            ctx.font = '12px Arial';
            ctx.fillStyle = axisColor;
            
            const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
            const chartHeight = canvas.height - chartPadding.top - chartPadding.bottom;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(chartPadding.left, chartPadding.top + chartHeight);
            ctx.lineTo(chartPadding.left + chartWidth, chartPadding.top + chartHeight);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(chartPadding.left, chartPadding.top);
            ctx.lineTo(chartPadding.left, chartPadding.top + chartHeight);
            ctx.stroke();
            
            // X-axis label
            ctx.textAlign = 'center';
            ctx.fillText('Iteration', chartPadding.left + chartWidth / 2, canvas.height - 20);
            
            // Y-axis label
            ctx.save();
            ctx.translate(20, chartPadding.top + chartHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Loss', 0, 0);
            ctx.restore();
            
            // Draw axis tick marks and values
            drawAxisTicks();
        }
        
        // Draw axis tick marks and values with dynamic scaling
        function drawAxisTicks() {
            ctx.font = '10px Arial';
            ctx.fillStyle = axisColor;
            
            const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
            const chartHeight = canvas.height - chartPadding.top - chartPadding.bottom;
            const ranges = calculateAxisRanges();
            
            // X-axis ticks
            for (let i = 0; i <= 5; i++) {
                const iteration = ranges.iteration.min + (ranges.iteration.max - ranges.iteration.min) * i / 5;
                const x = chartPadding.left + (chartWidth * i / 5);
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(iteration).toString(), x, chartPadding.top + chartHeight + 15);
            }
            
            // Y-axis ticks
            for (let i = 0; i <= 4; i++) {
                const loss = ranges.loss.min + (ranges.loss.max - ranges.loss.min) * (4 - i) / 4;
                const y = chartPadding.top + (chartHeight * i / 4);
                ctx.textAlign = 'right';
                ctx.fillText(loss.toFixed(3), chartPadding.left - 10, y + 4);
            }
        }
        
        // Draw the loss curve line with dynamic scaling
        function drawLossLine() {
            if (lossData.length < 1) return;
            
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
            const chartHeight = canvas.height - chartPadding.top - chartPadding.bottom;
            const ranges = calculateAxisRanges();
            
            const iterationRange = ranges.iteration.max - ranges.iteration.min;
            const lossRange = ranges.loss.max - ranges.loss.min;
            
            // Draw connecting line for multiple points
            if (lossData.length > 1) {
                ctx.beginPath();
                for (let i = 0; i < lossData.length; i++) {
                    const point = lossData[i];
                    const x = chartPadding.left + ((point.iteration - ranges.iteration.min) / iterationRange) * chartWidth;
                    const y = chartPadding.top + chartHeight - ((point.loss - ranges.loss.min) / lossRange) * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
            
            // Draw data points
            ctx.fillStyle = lineColor;
            for (let i = 0; i < lossData.length; i++) {
                const point = lossData[i];
                const x = chartPadding.left + ((point.iteration - ranges.iteration.min) / iterationRange) * chartWidth;
                const y = chartPadding.top + chartHeight - ((point.loss - ranges.loss.min) / lossRange) * chartHeight;
                
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        // Draw empty chart message
        function drawEmptyMessage() {
            ctx.font = '16px Arial';
            ctx.fillStyle = '#999';
            ctx.textAlign = 'center';
            ctx.fillText('Waiting for training data...', canvas.width / 2, canvas.height / 2);
        }
        
        // Add loss data point and update chart with real-time scaling
        function addLossDataPoint(iteration, loss, timestamp) {
            // Validate input data
            if (!isValidDataPoint(iteration, loss)) {
                console.warn('Invalid data point:', { iteration, loss, timestamp });
                return;
            }
            
            try {
                if (useChartJs) {
                    addLossDataPointChartJs(iteration, loss, timestamp);
                } else {
                    addLossDataPointCanvas(iteration, loss, timestamp);
                }
            } catch (error) {
                console.error('Error adding data point to chart:', error);
            }
        }
        
        // Validate data point values
        function isValidDataPoint(iteration, loss) {
            // Check for required values
            if (iteration === undefined || loss === undefined) {
                return false;
            }
            
            // Check data types
            if (typeof iteration !== 'number' || typeof loss !== 'number') {
                return false;
            }
            
            // Check for valid ranges
            if (!isFinite(iteration) || !isFinite(loss)) {
                return false;
            }
            
            // Check for reasonable ranges
            if (iteration < 0 || loss < 0 || loss > 1000) {
                console.warn('Data point outside expected range:', { iteration, loss });
                // Allow but warn - might be legitimate for some models
            }
            
            return true;
        }
        
        // Add data point to Chart.js chart with enhanced performance and timestamp tracking
        function addLossDataPointChartJs(iteration, loss, timestamp) {
            const maxPoints = chartConfig.maxDataPoints; // Use configuration value
            
            // Use current timestamp if not provided
            const dataTimestamp = timestamp || Date.now() / 1000;
            
            // Enhanced real-time data point addition using Chart.js 4.x optimized API
            if (lossChart && lossChart.data) {
                // Use Chart.js recommended approach for real-time data updates
                const data = lossChart.data;
                
                // Add new data point using Chart.js addData pattern
                data.labels.push(iteration);
                data.datasets[0].data.push({
                    x: iteration,
                    y: loss,
                    timestamp: dataTimestamp
                });
                
                // Update additional tracking arrays
                chartJsData.timestamps.push(dataTimestamp);
                chartJsData.iterations.push(iteration);
                
                // Memory management: remove oldest points when limit exceeded (Requirement 1.6)
                if (data.labels.length > maxPoints) {
                    // Calculate number of points to remove (remove 10% extra as buffer)
                    const removalCount = Math.max(1, Math.floor(data.labels.length * 0.1));
                    
                    // Remove oldest data using optimized bulk removal
                    data.labels.splice(0, removalCount);
                    data.datasets[0].data.splice(0, removalCount);
                    chartJsData.timestamps.splice(0, removalCount);
                    chartJsData.iterations.splice(0, removalCount);
                    
                    // Log memory management action for debugging
                    console.debug(`Chart memory management: Removed ${removalCount} oldest data points, now displaying ${data.labels.length} points`);
                    
                    // Trigger memory check after large removals
                    if (memoryMonitoringEnabled && removalCount > 10) {
                        setTimeout(checkMemoryUsage, 1000);
                    }
                }
                
                // Optimized chart update with performance monitoring
                const updateStart = performance.now();
                
                // Use Chart.js 4.x optimized update modes for real-time performance
                if (lossChart.updateRealtime) {
                    // Use custom optimized update method if available
                    lossChart.updateRealtime(chartConfig.maxUpdateRate);
                } else {
                    // Fallback to Chart.js standard update with animation control
                    // 'none' mode provides fastest updates for real-time data
                    lossChart.update('none');
                }
                
                // Performance monitoring for update optimization
                const updateDuration = performance.now() - updateStart;
                if (updateDuration > 50) { // Log slow updates (>50ms)
                    console.warn(`Chart update took ${updateDuration.toFixed(2)}ms - consider optimization`);
                }
                
            } else {
                // Fallback to legacy data structure if chart not properly initialized
                console.warn('Chart.js instance not available, using fallback data structure');
                
                chartJsData.labels.push(iteration);
                chartJsData.datasets[0].data.push(loss);
                chartJsData.timestamps.push(dataTimestamp);
                chartJsData.iterations.push(iteration);
                
                // Memory management for fallback mode
                if (chartJsData.labels.length > maxPoints) {
                    chartJsData.labels.shift();
                    chartJsData.datasets[0].data.shift();
                    chartJsData.timestamps.shift();
                    chartJsData.iterations.shift();
                }
                
                // Attempt chart update if chart instance exists
                if (lossChart) {
                    try {
                        lossChart.update('none');
                    } catch (error) {
                        console.error('Failed to update chart in fallback mode:', error);
                    }
                }
            }
        }
        
        // Add multiple data points in batch for optimal performance
        function addBatchLossDataPoints(dataPoints) {
            if (!Array.isArray(dataPoints) || dataPoints.length === 0) {
                console.warn('Invalid batch data points provided:', dataPoints);
                return;
            }
            
            console.debug(`Adding batch of ${dataPoints.length} data points to chart`);
            
            if (useChartJs && lossChart && lossChart.data) {
                const data = lossChart.data;
                const maxPoints = chartConfig.maxDataPoints;
                const batchStart = performance.now();
                
                // Process each data point in the batch
                for (const point of dataPoints) {
                    if (isValidDataPoint(point.iteration, point.loss)) {
                        const dataTimestamp = point.timestamp || Date.now() / 1000;
                        
                        // Add data point using optimized Chart.js pattern
                        data.labels.push(point.iteration);
                        data.datasets[0].data.push({
                            x: point.iteration,
                            y: point.loss,
                            timestamp: dataTimestamp
                        });
                        
                        // Update tracking arrays
                        chartJsData.timestamps.push(dataTimestamp);
                        chartJsData.iterations.push(point.iteration);
                    }
                }
                
                // Apply memory management after batch processing
                const pointsToRemove = Math.max(0, data.labels.length - maxPoints);
                if (pointsToRemove > 0) {
                    console.debug(`Removing ${pointsToRemove} oldest points for batch memory management`);
                    
                    // Remove oldest points using optimized bulk removal
                    data.labels.splice(0, pointsToRemove);
                    data.datasets[0].data.splice(0, pointsToRemove);
                    chartJsData.timestamps.splice(0, pointsToRemove);
                    chartJsData.iterations.splice(0, pointsToRemove);
                    
                    // Trigger memory check after significant batch operations
                    if (memoryMonitoringEnabled && pointsToRemove > 50) {
                        setTimeout(checkMemoryUsage, 2000);
                    }
                }
                
                // Single chart update for entire batch (performance optimization)
                const updateStart = performance.now();
                
                if (lossChart.updateRealtime) {
                    lossChart.updateRealtime(chartConfig.maxUpdateRate);
                } else {
                    lossChart.update('none'); // No animation for batch updates
                }
                
                const updateDuration = performance.now() - updateStart;
                const batchDuration = performance.now() - batchStart;
                
                console.debug(`Batch update completed: ${batchDuration.toFixed(2)}ms total, ${updateDuration.toFixed(2)}ms chart update`);
                
                if (updateDuration > 100) { // Log slow batch updates
                    console.warn(`Batch chart update took ${updateDuration.toFixed(2)}ms for ${dataPoints.length} points - consider reducing batch size`);
                }
            } else {
                // Fallback to individual point addition for non-Chart.js mode
                console.debug('Using fallback mode for batch data points');
                for (const point of dataPoints) {
                    if (isValidDataPoint(point.iteration, point.loss)) {
                        addLossDataPointCanvas(point.iteration, point.loss, point.timestamp);
                    }
                }
            }
        }
        
        // Add data point to canvas chart (fallback)
        function addLossDataPointCanvas(iteration, loss, timestamp) {
            lossData.push({ iteration, loss, timestamp: timestamp || Date.now() / 1000 });
            
            // Keep only last 100 points for performance
            if (lossData.length > 100) {
                lossData.shift();
            }
            
            // Trigger smooth real-time chart update
            requestAnimationFrame(() => {
                drawChart();
            });
        }
        
        // Calculate dynamic axis ranges with proper margins
        function calculateAxisRanges() {
            if (lossData.length === 0) {
                return { iteration: { min: 0, max: 100 }, loss: { min: 0, max: 1 } };
            }
            
            const iterations = lossData.map(d => d.iteration);
            const losses = lossData.map(d => d.loss);
            
            const iterationMin = Math.min(...iterations);
            const iterationMax = Math.max(...iterations);
            const lossMin = Math.min(...losses);
            const lossMax = Math.max(...losses);
            
            // Add margins for better visualization
            const iterationRange = iterationMax - iterationMin || 1;
            const lossRange = lossMax - lossMin || 0.1;
            
            return {
                iteration: {
                    min: Math.max(0, iterationMin - iterationRange * 0.05),
                    max: iterationMax + iterationRange * 0.05
                },
                loss: {
                    min: Math.max(0, lossMin - lossRange * 0.1),
                    max: lossMax + lossRange * 0.1
                }
            };
        }
        
        // Tab switching functionality
        function switchTab(tabId) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab content
            const selectedTab = document.getElementById(tabId);
            if (selectedTab) {
                selectedTab.classList.add('active');
            }
            
            // Add active class to clicked button
            const clickedButton = event ? event.target : document.querySelector(`[onclick="switchTab('${tabId}')"]`);
            if (clickedButton) {
                clickedButton.classList.add('active');
            }
            
            // Handle tab-specific initialization
            if (tabId === 'parameter-viz-tab') {
                initParameterVisualization();
            }
        }
        
        // Toggle settings panel
        function toggleSettingsPanel() {
            const content = document.getElementById('settings-content');
            const toggle = document.getElementById('settings-toggle');
            
            if (content && toggle) {
                content.classList.toggle('expanded');
                toggle.classList.toggle('expanded');
            }
        }
        
        // 3D Parameter Visualization Variables
        let parameterScene = null;
        let parameterCamera = null;
        let parameterRenderer = null;
        let parameterControls = null;
        let parameterPoints = null;
        let parameterData = null;
        let parameterVisualizationInitialized = false;
        
        // Initialize 3D parameter visualization
        function initParameterVisualization() {
            if (parameterVisualizationInitialized) {
                return; // Already initialized
            }
            
            try {
                const canvas = document.getElementById('parameter-3d-canvas');
                const container = canvas.parentElement;
                
                // Check for WebGL support
                if (!isWebGLSupported()) {
                    showParameterFallback('WebGL not supported in this browser');
                    return;
                }
                
                // Initialize Three.js scene
                parameterScene = new THREE.Scene();
                parameterScene.background = new THREE.Color(0x2c3e50);
                
                // Initialize camera with perspective projection
                const aspect = container.clientWidth / container.clientHeight;
                parameterCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                parameterCamera.position.set(10, 10, 10);
                parameterCamera.lookAt(0, 0, 0);
                
                // Initialize WebGL renderer
                parameterRenderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true,
                    alpha: false
                });
                parameterRenderer.setSize(container.clientWidth, container.clientHeight);
                parameterRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Initialize orbit controls for camera manipulation
                parameterControls = new THREE.OrbitControls(parameterCamera, parameterRenderer.domElement);
                parameterControls.enableDamping = true;
                parameterControls.dampingFactor = 0.05;
                parameterControls.enableZoom = true;
                parameterControls.enableRotate = true;
                parameterControls.enablePan = true;
                
                // Configure control limits for better user experience
                parameterControls.minDistance = 5;
                parameterControls.maxDistance = 100;
                parameterControls.maxPolarAngle = Math.PI; // Allow full rotation
                
                // Add mouse interaction for parameter inspection
                canvas.addEventListener('mousemove', onParameterMouseMove);
                canvas.addEventListener('click', onParameterClick);
                
                // Add lighting to the scene
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                parameterScene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                parameterScene.add(directionalLight);
                
                // Add coordinate system helper
                const axesHelper = new THREE.AxesHelper(5);
                parameterScene.add(axesHelper);
                
                // Handle window resize
                window.addEventListener('resize', onParameterVisualizationResize);
                
                // Start render loop
                animateParameterVisualization();
                
                parameterVisualizationInitialized = true;
                updateParameterInfo('3D visualization initialized. Waiting for parameter data...');
                
                // Setup parameter control event listeners
                setupParameterControls();
                
                console.log('3D parameter visualization initialized successfully');
                
            } catch (error) {
                console.error('Failed to initialize 3D parameter visualization:', error);
                showParameterFallback('Failed to initialize 3D visualization: ' + error.message);
            }
        }
        
        // Check WebGL support
        function isWebGLSupported() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext && 
                         (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
                return false;
            }
        }
        
        // Handle window resize for 3D visualization
        function onParameterVisualizationResize() {
            if (!parameterCamera || !parameterRenderer) return;
            
            const canvas = document.getElementById('parameter-3d-canvas');
            const container = canvas.parentElement;
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            parameterCamera.aspect = width / height;
            parameterCamera.updateProjectionMatrix();
            
            parameterRenderer.setSize(width, height);
        }
        
        // Animation loop for 3D parameter visualization
        function animateParameterVisualization() {
            if (!parameterRenderer || !parameterScene || !parameterCamera) {
                return;
            }
            
            requestAnimationFrame(animateParameterVisualization);
            
            // Update controls
            if (parameterControls) {
                parameterControls.update();
            }
            
            // Render the scene
            parameterRenderer.render(parameterScene, parameterCamera);
        }
        
        // Show fallback message for parameter visualization
        function showParameterFallback(message) {
            const loadingElement = document.getElementById('parameter-loading');
            if (loadingElement) {
                loadingElement.textContent = message;
                loadingElement.style.color = '#e74c3c';
            }
            
            // Initialize 2D fallback visualization
            init2DParameterFallback();
        }
        
        // 2D Canvas fallback variables
        let fallbackCanvas = null;
        let fallbackCtx = null;
        let fallbackInitialized = false;
        
        // Initialize 2D canvas fallback for parameter visualization
        function init2DParameterFallback() {
            if (fallbackInitialized) return;
            
            try {
                const container = document.querySelector('.parameter-3d-container');
                if (!container) return;
                
                // Create 2D canvas element
                fallbackCanvas = document.createElement('canvas');
                fallbackCanvas.id = 'parameter-2d-canvas';
                fallbackCanvas.style.width = '100%';
                fallbackCanvas.style.height = '100%';
                fallbackCanvas.style.backgroundColor = '#34495e';
                fallbackCanvas.style.borderRadius = '6px';
                
                // Replace 3D canvas with 2D canvas
                const canvas3d = document.getElementById('parameter-3d-canvas');
                if (canvas3d) {
                    container.replaceChild(fallbackCanvas, canvas3d);
                }
                
                // Get 2D context
                fallbackCtx = fallbackCanvas.getContext('2d');
                if (!fallbackCtx) {
                    throw new Error('2D canvas context not available');
                }
                
                // Set canvas size
                resizeFallbackCanvas();
                
                // Add resize listener
                window.addEventListener('resize', resizeFallbackCanvas);
                
                fallbackInitialized = true;
                
                // Draw initial message
                drawFallbackMessage('2D Parameter Visualization (WebGL Fallback)');
                
                console.log('2D parameter visualization fallback initialized');
                
            } catch (error) {
                console.error('Failed to initialize 2D fallback:', error);
                showParameterFallback('Visualization not available: ' + error.message);
            }
        }
        
        // Resize 2D fallback canvas
        function resizeFallbackCanvas() {
            if (!fallbackCanvas || !fallbackCtx) return;
            
            const container = fallbackCanvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            fallbackCanvas.width = rect.width;
            fallbackCanvas.height = rect.height;
            
            // Redraw content after resize
            if (parameterData) {
                draw2DParameterVisualization(parameterData);
            } else {
                drawFallbackMessage('2D Parameter Visualization (WebGL Fallback)');
            }
        }
        
        // Draw message on 2D fallback canvas
        function drawFallbackMessage(message) {
            if (!fallbackCtx || !fallbackCanvas) return;
            
            fallbackCtx.clearRect(0, 0, fallbackCanvas.width, fallbackCanvas.height);
            
            fallbackCtx.fillStyle = '#ecf0f1';
            fallbackCtx.font = '16px Arial';
            fallbackCtx.textAlign = 'center';
            fallbackCtx.textBaseline = 'middle';
            
            fallbackCtx.fillText(message, fallbackCanvas.width / 2, fallbackCanvas.height / 2);
        }
        
        // Draw 2D parameter visualization (fallback)
        function draw2DParameterVisualization(parameters) {
            if (!fallbackCtx || !fallbackCanvas || !parameters) return;
            
            try {
                // Clear canvas
                fallbackCtx.clearRect(0, 0, fallbackCanvas.width, fallbackCanvas.height);
                
                // Get current filter settings
                const parameterType = document.getElementById('parameter-type-select').value;
                const layerFilter = document.getElementById('layer-filter-select').value;
                const pointSize = parseFloat(document.getElementById('point-size-slider').value);
                
                const width = fallbackCanvas.width;
                const height = fallbackCanvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                
                let pointCount = 0;
                
                // Draw token embeddings as circles
                if ((parameterType === 'all' || parameterType === 'token_embeddings') && parameters.token_embeddings) {
                    fallbackCtx.fillStyle = '#3498db';
                    
                    for (let i = 0; i < parameters.token_embeddings.length && i < 200; i++) {
                        const embedding = parameters.token_embeddings[i];
                        if (embedding.values && embedding.values.length >= 2) {
                            const x = centerX + (embedding.values[0] * 100);
                            const y = centerY + (embedding.values[1] * 100);
                            
                            fallbackCtx.beginPath();
                            fallbackCtx.arc(x, y, pointSize, 0, 2 * Math.PI);
                            fallbackCtx.fill();
                            pointCount++;
                        }
                    }
                }
                
                // Draw position embeddings as squares
                if ((parameterType === 'all' || parameterType === 'position_embeddings') && parameters.position_embeddings) {
                    fallbackCtx.fillStyle = '#e74c3c';
                    
                    for (let i = 0; i < parameters.position_embeddings.length && i < 100; i++) {
                        const embedding = parameters.position_embeddings[i];
                        if (embedding.values && embedding.values.length >= 2) {
                            const x = centerX + (embedding.values[0] * 100) + 150;
                            const y = centerY + (embedding.values[1] * 100);
                            
                            fallbackCtx.fillRect(x - pointSize, y - pointSize, pointSize * 2, pointSize * 2);
                            pointCount++;
                        }
                    }
                }
                
                // Draw layer weights as triangles
                if ((parameterType === 'all' || parameterType === 'layer_weights') && parameters.layer_weights) {
                    fallbackCtx.fillStyle = '#f39c12';
                    
                    for (let i = 0; i < parameters.layer_weights.length && i < 300; i++) {
                        const weight = parameters.layer_weights[i];
                        
                        // Filter by layer if specified
                        if (layerFilter !== 'all' && weight.layer !== parseInt(layerFilter)) {
                            continue;
                        }
                        
                        const x = centerX + (weight.layer * 20) - 100;
                        const y = centerY + (weight.value * 1000);
                        
                        // Draw triangle
                        fallbackCtx.beginPath();
                        fallbackCtx.moveTo(x, y - pointSize);
                        fallbackCtx.lineTo(x - pointSize, y + pointSize);
                        fallbackCtx.lineTo(x + pointSize, y + pointSize);
                        fallbackCtx.closePath();
                        fallbackCtx.fill();
                        pointCount++;
                    }
                }
                
                // Draw legend
                drawFallbackLegend(pointCount);
                
            } catch (error) {
                console.error('Error drawing 2D parameter visualization:', error);
                drawFallbackMessage('Error drawing 2D visualization');
            }
        }
        
        // Draw legend for 2D fallback
        function drawFallbackLegend(pointCount) {
            if (!fallbackCtx) return;
            
            const legendX = 10;
            const legendY = 10;
            
            fallbackCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            fallbackCtx.fillRect(legendX, legendY, 200, 80);
            
            fallbackCtx.fillStyle = '#ecf0f1';
            fallbackCtx.font = '12px Arial';
            fallbackCtx.textAlign = 'left';
            
            fallbackCtx.fillText('2D Parameter Visualization', legendX + 5, legendY + 15);
            fallbackCtx.fillText(`Points: ${pointCount}`, legendX + 5, legendY + 30);
            
            // Legend items
            fallbackCtx.fillStyle = '#3498db';
            fallbackCtx.beginPath();
            fallbackCtx.arc(legendX + 15, legendY + 45, 3, 0, 2 * Math.PI);
            fallbackCtx.fill();
            fallbackCtx.fillStyle = '#ecf0f1';
            fallbackCtx.fillText('Token Embeddings', legendX + 25, legendY + 50);
            
            fallbackCtx.fillStyle = '#e74c3c';
            fallbackCtx.fillRect(legendX + 12, legendY + 57, 6, 6);
            fallbackCtx.fillStyle = '#ecf0f1';
            fallbackCtx.fillText('Position Embeddings', legendX + 25, legendY + 65);
        }
        
        // Update parameter info display
        function updateParameterInfo(message) {
            const infoElement = document.getElementById('parameter-info');
            if (infoElement) {
                infoElement.textContent = message;
            }
        }
        
        // Handle parameter update messages from WebSocket
        function handleParameterUpdate(data) {
            try {
                if (!data.parameters || !data.iteration) {
                    console.warn('Invalid parameter update data structure:', data);
                    return;
                }
                
                console.log(`Received parameter data for iteration ${data.iteration}`);
                
                // Store parameter data for visualization
                parameterData = data.parameters;
                
                // Update parameter info
                const tokenCount = data.parameters.token_embeddings ? data.parameters.token_embeddings.length : 0;
                const positionCount = data.parameters.position_embeddings ? data.parameters.position_embeddings.length : 0;
                const layerCount = data.parameters.layer_weights ? data.parameters.layer_weights.length : 0;
                
                updateParameterInfo(`Iteration ${data.iteration}: ${tokenCount} tokens, ${positionCount} positions, ${layerCount} layer weights`);
                
                // Update 3D visualization if initialized
                if (parameterVisualizationInitialized) {
                    updateParameterVisualization(data.parameters);
                } else if (fallbackInitialized) {
                    // Update 2D fallback visualization
                    draw2DParameterVisualization(data.parameters);
                }
                
                // Update layer filter options
                updateLayerFilterOptions(data.parameters.metadata);
                
            } catch (error) {
                console.error('Error handling parameter update:', error);
            }
        }
        
        // Update layer filter dropdown options
        function updateLayerFilterOptions(metadata) {
            if (!metadata || !metadata.n_layer) return;
            
            const layerSelect = document.getElementById('layer-filter-select');
            if (!layerSelect) return;
            
            // Store current selection
            const currentValue = layerSelect.value;
            
            // Clear existing options except "All Layers"
            while (layerSelect.children.length > 1) {
                layerSelect.removeChild(layerSelect.lastChild);
            }
            
            // Add layer options with component breakdown
            for (let i = 0; i < metadata.n_layer; i++) {
                const option = document.createElement('option');
                option.value = i.toString();
                option.textContent = `Layer ${i}`;
                layerSelect.appendChild(option);
            }
            
            // Add component-specific options
            const components = ['attention', 'mlp', 'layernorm'];
            for (const component of components) {
                const option = document.createElement('option');
                option.value = `component_${component}`;
                option.textContent = `All ${component.charAt(0).toUpperCase() + component.slice(1)} Components`;
                layerSelect.appendChild(option);
            }
            
            // Restore selection if still valid
            if (currentValue && [...layerSelect.options].some(opt => opt.value === currentValue)) {
                layerSelect.value = currentValue;
            }
        }
        
        // Update 3D parameter visualization with new data
        function updateParameterVisualization(parameters) {
            if (!parameterScene || !parameterVisualizationInitialized) {
                console.warn('3D visualization not initialized');
                return;
            }
            
            try {
                // Remove existing parameter points
                if (parameterPoints) {
                    parameterScene.remove(parameterPoints);
                    parameterPoints = null;
                }
                
                // Get current filter settings
                const parameterType = document.getElementById('parameter-type-select').value;
                const layerFilter = document.getElementById('layer-filter-select').value;
                const pointSize = parseFloat(document.getElementById('point-size-slider').value);
                const colorScheme = document.getElementById('color-scheme-select').value;
                const showTokens = document.getElementById('show-tokens').checked;
                const showPositions = document.getElementById('show-positions').checked;
                const showLayers = document.getElementById('show-layers').checked;
                
                // Create point cloud based on selected parameter type and filters
                const pointsData = preparePointCloudData(parameters, parameterType, layerFilter, colorScheme, {
                    showTokens, showPositions, showLayers
                });
                
                if (pointsData.positions.length > 0) {
                    createParameterPointCloud(pointsData, pointSize);
                    updateParameterInfo(`Displaying ${pointsData.positions.length / 3} parameter points`);
                } else {
                    updateParameterInfo('No parameter data to display with current filters');
                }
                
            } catch (error) {
                console.error('Error updating parameter visualization:', error);
                updateParameterInfo('Error updating visualization: ' + error.message);
            }
        }
        
        // Prepare point cloud data from parameters
        function preparePointCloudData(parameters, parameterType, layerFilter, colorScheme = 'magnitude', visibility = {}) {
            const positions = [];
            const colors = [];
            const metadata = [];
            
            const { showTokens = true, showPositions = true, showLayers = true } = visibility;
            
            // Process token embeddings
            if (showTokens && (parameterType === 'all' || parameterType === 'token_embeddings') && parameters.token_embeddings) {
                for (const embedding of parameters.token_embeddings) {
                    if (embedding.values && embedding.values.length >= 3) {
                        // Use first 3 dimensions for 3D position
                        positions.push(embedding.values[0] * 10); // Scale for visibility
                        positions.push(embedding.values[1] * 10);
                        positions.push(embedding.values[2] * 10);
                        
                        // Color based on selected scheme
                        const color = getParameterColor('token_embedding', embedding, colorScheme);
                        colors.push(color.r);
                        colors.push(color.g);
                        colors.push(color.b);
                        
                        metadata.push({
                            type: 'token_embedding',
                            token_id: embedding.token_id,
                            magnitude: embedding.magnitude
                        });
                    }
                }
            }
            
            // Process position embeddings
            if (showPositions && (parameterType === 'all' || parameterType === 'position_embeddings') && parameters.position_embeddings) {
                for (const embedding of parameters.position_embeddings) {
                    if (embedding.values && embedding.values.length >= 3) {
                        // Use first 3 dimensions for 3D position, offset slightly
                        positions.push(embedding.values[0] * 10 + 20); // Offset to separate from tokens
                        positions.push(embedding.values[1] * 10);
                        positions.push(embedding.values[2] * 10);
                        
                        // Color based on selected scheme
                        const color = getParameterColor('position_embedding', embedding, colorScheme);
                        colors.push(color.r);
                        colors.push(color.g);
                        colors.push(color.b);
                        
                        metadata.push({
                            type: 'position_embedding',
                            position: embedding.position,
                            magnitude: embedding.magnitude
                        });
                    }
                }
            }
            
            // Process layer weights
            if (showLayers && (parameterType === 'all' || parameterType === 'layer_weights') && parameters.layer_weights) {
                for (const weight of parameters.layer_weights) {
                    // Filter by layer or component if specified
                    if (layerFilter !== 'all') {
                        if (layerFilter.startsWith('component_')) {
                            const component = layerFilter.replace('component_', '');
                            if (weight.component !== component) {
                                continue;
                            }
                        } else if (weight.layer !== parseInt(layerFilter)) {
                            continue;
                        }
                    }
                    
                    // Create 3D position from weight properties
                    const x = weight.layer * 5; // Spread layers along X axis
                    const y = (weight.index % 100) * 0.1; // Spread indices along Y axis
                    const z = weight.value * 50; // Weight value as Z position
                    
                    positions.push(x);
                    positions.push(y);
                    positions.push(z);
                    
                    // Color based on selected scheme
                    const color = getParameterColor('layer_weight', weight, colorScheme);
                    colors.push(color.r);
                    colors.push(color.g);
                    colors.push(color.b);
                    
                    metadata.push({
                        type: 'layer_weight',
                        layer: weight.layer,
                        component: weight.component,
                        value: weight.value,
                        magnitude: weight.magnitude
                    });
                }
            }
            
            return { positions, colors, metadata };
        }
        
        // Create 3D point cloud from prepared data
        function createParameterPointCloud(pointsData, pointSize) {
            if (!parameterScene) return;
            
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(pointsData.positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(pointsData.colors, 3));
            
            // Create material
            const material = new THREE.PointsMaterial({
                size: pointSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            // Create points object
            parameterPoints = new THREE.Points(geometry, material);
            parameterScene.add(parameterPoints);
            
            // Store metadata for interaction
            parameterPoints.userData = { metadata: pointsData.metadata };
            
            console.log(`Created point cloud with ${pointsData.positions.length / 3} points`);
        }
        
        // Convert HSL to RGB for color generation
        function hslToRgb(h, s, l) {
            h /= 360;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const k = (n + h / (1/12)) % 1;
                return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            };
            return { r: f(0), g: f(8), b: f(4) };
        }
        
        // Get parameter color based on scheme
        function getParameterColor(parameterType, parameter, colorScheme) {
            switch (colorScheme) {
                case 'magnitude':
                    const normalizedMagnitude = Math.min(parameter.magnitude / 10, 1);
                    return {
                        r: normalizedMagnitude,
                        g: 0.2,
                        b: 1 - normalizedMagnitude
                    };
                    
                case 'type':
                    switch (parameterType) {
                        case 'token_embedding':
                            return { r: 0.2, g: 0.6, b: 1.0 }; // Blue
                        case 'position_embedding':
                            return { r: 1.0, g: 0.6, b: 0.2 }; // Orange
                        case 'layer_weight':
                            return { r: 0.2, g: 1.0, b: 0.6 }; // Green
                        default:
                            return { r: 0.5, g: 0.5, b: 0.5 }; // Gray
                    }
                    
                case 'layer':
                    if (parameterType === 'layer_weight' && parameter.layer !== undefined) {
                        const layerHue = (parameter.layer / 12) * 360; // Assuming max 12 layers
                        return hslToRgb(layerHue, 0.8, 0.6);
                    } else {
                        // For non-layer parameters, use type-based coloring
                        return getParameterColor(parameterType, parameter, 'type');
                    }
                    
                default:
                    return { r: 0.5, g: 0.5, b: 0.5 }; // Default gray
            }
        }
        
        // Mouse interaction variables
        let mousePosition = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let hoveredPoint = null;
        
        // Handle mouse movement for parameter inspection
        function onParameterMouseMove(event) {
            if (!parameterCamera || !parameterPoints) return;
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            
            // Calculate mouse position in normalized device coordinates
            mousePosition.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mousePosition.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mousePosition, parameterCamera);
            
            // Check for intersections with parameter points
            const intersects = raycaster.intersectObject(parameterPoints);
            
            if (intersects.length > 0) {
                const intersection = intersects[0];
                const pointIndex = intersection.index;
                
                if (hoveredPoint !== pointIndex) {
                    hoveredPoint = pointIndex;
                    showParameterTooltip(pointIndex, event.clientX, event.clientY);
                    canvas.style.cursor = 'pointer';
                }
            } else {
                if (hoveredPoint !== null) {
                    hoveredPoint = null;
                    hideParameterTooltip();
                    canvas.style.cursor = 'default';
                }
            }
        }
        
        // Handle mouse click for parameter selection
        function onParameterClick(event) {
            if (!parameterCamera || !parameterPoints) return;
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            
            // Calculate mouse position in normalized device coordinates
            mousePosition.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mousePosition.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mousePosition, parameterCamera);
            
            // Check for intersections with parameter points
            const intersects = raycaster.intersectObject(parameterPoints);
            
            if (intersects.length > 0) {
                const intersection = intersects[0];
                const pointIndex = intersection.index;
                selectParameter(pointIndex);
            }
        }
        
        // Show parameter tooltip on hover
        function showParameterTooltip(pointIndex, x, y) {
            if (!parameterPoints || !parameterPoints.userData.metadata) return;
            
            const metadata = parameterPoints.userData.metadata[pointIndex];
            if (!metadata) return;
            
            // Update info panel
            let infoText = '';
            let detailText = '';
            
            switch (metadata.type) {
                case 'token_embedding':
                    infoText = `Token Embedding ${metadata.token_id}`;
                    detailText = `Token ID: ${metadata.token_id}\nMagnitude: ${metadata.magnitude.toFixed(4)}\nType: Token Embedding\n\nHover over points for details\nClick to select`;
                    break;
                case 'position_embedding':
                    infoText = `Position Embedding ${metadata.position}`;
                    detailText = `Position: ${metadata.position}\nMagnitude: ${metadata.magnitude.toFixed(4)}\nType: Position Embedding\n\nHover over points for details\nClick to select`;
                    break;
                case 'layer_weight':
                    infoText = `Layer ${metadata.layer} ${metadata.component}`;
                    detailText = `Layer: ${metadata.layer}\nComponent: ${metadata.component}\nValue: ${metadata.value.toFixed(6)}\nMagnitude: ${metadata.magnitude.toFixed(6)}\nType: Layer Weight\n\nHover over points for details\nClick to select`;
                    break;
            }
            
            updateParameterInfo(infoText);
            
            // Show detailed tooltip
            const tooltip = document.getElementById('parameter-tooltip');
            if (tooltip) {
                tooltip.textContent = detailText;
                tooltip.style.display = 'block';
                tooltip.style.left = (x + 15) + 'px';
                tooltip.style.top = (y - 10) + 'px';
            }
            
            // Show details panel
            const details = document.getElementById('parameter-details');
            if (details) {
                details.textContent = detailText;
                details.style.display = 'block';
            }
        }
        
        // Hide parameter tooltip
        function hideParameterTooltip() {
            // Hide tooltip
            const tooltip = document.getElementById('parameter-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
            
            // Hide details panel
            const details = document.getElementById('parameter-details');
            if (details) {
                details.style.display = 'none';
            }
            
            // Reset info panel
            if (parameterData) {
                const tokenCount = parameterData.token_embeddings ? parameterData.token_embeddings.length : 0;
                const positionCount = parameterData.position_embeddings ? parameterData.position_embeddings.length : 0;
                const layerCount = parameterData.layer_weights ? parameterData.layer_weights.length : 0;
                updateParameterInfo(`${tokenCount} tokens, ${positionCount} positions, ${layerCount} layer weights`);
            }
        }
        
        // Select parameter for detailed inspection
        function selectParameter(pointIndex) {
            if (!parameterPoints || !parameterPoints.userData.metadata) return;
            
            const metadata = parameterPoints.userData.metadata[pointIndex];
            if (!metadata) return;
            
            console.log('Selected parameter:', metadata);
            
            // Could expand this to show detailed parameter information in a panel
            let detailText = 'Selected: ';
            switch (metadata.type) {
                case 'token_embedding':
                    detailText += `Token ${metadata.token_id} (magnitude: ${metadata.magnitude.toFixed(4)})`;
                    break;
                case 'position_embedding':
                    detailText += `Position ${metadata.position} (magnitude: ${metadata.magnitude.toFixed(4)})`;
                    break;
                case 'layer_weight':
                    detailText += `Layer ${metadata.layer} ${metadata.component} (value: ${metadata.value.toFixed(6)})`;
                    break;
            }
            
            updateParameterInfo(detailText);
        }
        
        // Add control event listeners for real-time updates
        function setupParameterControls() {
            const parameterTypeSelect = document.getElementById('parameter-type-select');
            const layerFilterSelect = document.getElementById('layer-filter-select');
            const pointSizeSlider = document.getElementById('point-size-slider');
            const pointSizeValue = document.getElementById('point-size-value');
            const colorSchemeSelect = document.getElementById('color-scheme-select');
            const showTokens = document.getElementById('show-tokens');
            const showPositions = document.getElementById('show-positions');
            const showLayers = document.getElementById('show-layers');
            
            // Advanced settings controls
            const animationSpeedSlider = document.getElementById('animation-speed-slider');
            const animationSpeedValue = document.getElementById('animation-speed-value');
            const pointOpacitySlider = document.getElementById('point-opacity-slider');
            const pointOpacityValue = document.getElementById('point-opacity-value');
            const backgroundSelect = document.getElementById('background-select');
            const showGrid = document.getElementById('show-grid');
            
            // Parameter type selection
            if (parameterTypeSelect) {
                parameterTypeSelect.addEventListener('change', () => {
                    if (parameterData) {
                        updateParameterVisualization(parameterData);
                    }
                });
            }
            
            // Layer filter selection
            if (layerFilterSelect) {
                layerFilterSelect.addEventListener('change', () => {
                    if (parameterData) {
                        updateParameterVisualization(parameterData);
                    }
                });
            }
            
            // Point size control
            if (pointSizeSlider && pointSizeValue) {
                pointSizeSlider.addEventListener('input', () => {
                    const size = parseFloat(pointSizeSlider.value);
                    pointSizeValue.textContent = size;
                    
                    if (parameterPoints && parameterPoints.material) {
                        parameterPoints.material.size = size;
                    }
                });
            }
            
            // Color scheme selection
            if (colorSchemeSelect) {
                colorSchemeSelect.addEventListener('change', () => {
                    if (parameterData) {
                        updateParameterVisualization(parameterData);
                    }
                });
            }
            
            // Show/hide checkboxes
            const checkboxes = [showTokens, showPositions, showLayers];
            checkboxes.forEach(checkbox => {
                if (checkbox) {
                    checkbox.addEventListener('change', () => {
                        if (parameterData) {
                            updateParameterVisualization(parameterData);
                        }
                    });
                }
            });
            
            // Animation speed control
            if (animationSpeedSlider && animationSpeedValue) {
                animationSpeedSlider.addEventListener('input', () => {
                    const speed = parseFloat(animationSpeedSlider.value);
                    animationSpeedValue.textContent = speed.toFixed(1) + 'x';
                    // Animation speed would be used in future animation features
                });
            }
            
            // Point opacity control
            if (pointOpacitySlider && pointOpacityValue) {
                pointOpacitySlider.addEventListener('input', () => {
                    const opacity = parseFloat(pointOpacitySlider.value);
                    pointOpacityValue.textContent = opacity.toFixed(1);
                    
                    if (parameterPoints && parameterPoints.material) {
                        parameterPoints.material.opacity = opacity;
                        parameterPoints.material.transparent = opacity < 1.0;
                    }
                });
            }
            
            // Background selection
            if (backgroundSelect) {
                backgroundSelect.addEventListener('change', () => {
                    updateVisualizationBackground(backgroundSelect.value);
                });
            }
            
            // Grid toggle
            if (showGrid) {
                showGrid.addEventListener('change', () => {
                    toggleVisualizationGrid(showGrid.checked);
                });
            }
        }
        
        // Update visualization background
        function updateVisualizationBackground(backgroundType) {
            if (!parameterScene) return;
            
            switch (backgroundType) {
                case 'dark':
                    parameterScene.background = new THREE.Color(0x2c3e50);
                    break;
                case 'light':
                    parameterScene.background = new THREE.Color(0xf8f9fa);
                    break;
                case 'gradient':
                    // Create gradient background using a large sphere
                    const geometry = new THREE.SphereGeometry(500, 32, 32);
                    const material = new THREE.ShaderMaterial({
                        uniforms: {
                            topColor: { value: new THREE.Color(0x0077ff) },
                            bottomColor: { value: new THREE.Color(0x000033) },
                            offset: { value: 33 },
                            exponent: { value: 0.6 }
                        },
                        vertexShader: `
                            varying vec3 vWorldPosition;
                            void main() {
                                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                                vWorldPosition = worldPosition.xyz;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 topColor;
                            uniform vec3 bottomColor;
                            uniform float offset;
                            uniform float exponent;
                            varying vec3 vWorldPosition;
                            void main() {
                                float h = normalize(vWorldPosition + offset).y;
                                gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                            }
                        `,
                        side: THREE.BackSide
                    });
                    
                    // Remove existing gradient background
                    const existingGradient = parameterScene.getObjectByName('gradientBackground');
                    if (existingGradient) {
                        parameterScene.remove(existingGradient);
                    }
                    
                    const gradientMesh = new THREE.Mesh(geometry, material);
                    gradientMesh.name = 'gradientBackground';
                    parameterScene.add(gradientMesh);
                    parameterScene.background = null;
                    break;
            }
        }
        
        // Toggle visualization grid
        function toggleVisualizationGrid(show) {
            if (!parameterScene) return;
            
            // Remove existing grid
            const existingGrid = parameterScene.getObjectByName('parameterGrid');
            if (existingGrid) {
                parameterScene.remove(existingGrid);
            }
            
            if (show) {
                // Add grid helper
                const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
                gridHelper.name = 'parameterGrid';
                parameterScene.add(gridHelper);
            }
        }
        
        // Initialize HTTP polling connection on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Small delay to ensure layout is computed
            setTimeout(() => {
                console.log('ðŸš€ Starting dashboard initialization...');
                initChart();
                initConnection();
            }, 100);
            
            // Start memory monitoring for long training sessions
            startMemoryMonitoring();
        });
        
        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            // Clean up WebSocket connection
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.close(1000, 'Page unloading');
            }
            
            // Clean up polling if active
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }
            
            // Clean up ping interval
            stopPingInterval();
            
            // Clear reconnection timeout
            clearReconnectTimeout();
            
            // Stop memory monitoring
            stopMemoryMonitoring();
        });
    </script>
</body>
</html>